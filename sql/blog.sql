SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `blog_id` int NOT NULL AUTO_INCREMENT,
  `type_id` int NULL DEFAULT NULL,
  `user_id` int NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `first_picture` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `views` int NULL DEFAULT NULL,
  `appreciation` tinyint(1) NULL DEFAULT 0,
  `share_statement` tinyint(1) NULL DEFAULT 0,
  `comment` tinyint(1) NULL DEFAULT 0,
  `publish` tinyint(1) NULL DEFAULT 0,
  `recommend` tinyint(1) NULL DEFAULT 0,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `description` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  PRIMARY KEY (`blog_id`) USING BTREE,
  INDEX `FK_Reference_1`(`type_id`) USING BTREE,
  INDEX `FK_Reference_2`(`user_id`) USING BTREE,
  CONSTRAINT `FK_Reference_1` FOREIGN KEY (`type_id`) REFERENCES `type` (`type_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK_Reference_2` FOREIGN KEY (`user_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (1, 1, 1, 'SpringBoot简介', '# Spring Boot 简介\r\n\r\n## 原有 Spring 优缺点分析\r\n\r\n### Spring 的优点分析\r\n\r\n- Spring 是 Java 企业版（Java Enterprise Edition，JEE，也称 J2EE）的轻量级代替品。\r\n- 无需开发重量级的 Enterprise JavaBean（EJB），Spring 为企业级 Java 开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的 Java 对象（Plain Old Java Object，POJO）实现了 EJB 的功能。\r\n\r\n### Spring 的缺点分析\r\n\r\n- 虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring 用 XML 配置，而且是很多 XML 配置。Spring 2.5 引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式 XML 配置。Spring 3.0 引入了基于 Java 的配置，这是一种类型安全的可重构配置方式，可以代替 XML。\r\n- **复杂的配置**：项目中的各种配置都代表了开发时的损耗。因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。\r\n- **混乱的依赖管理**：项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。\r\n\r\n## Spring Boot 的概述\r\n\r\n### Spring Boot 解决上述 Spring 的缺点\r\n\r\n- Spring Boot 对上述 Spring 的缺点进行的改善和优化，基于**约定优于配置**的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。\r\n\r\n### Spring Boot 的特点\r\n\r\n- 为基于 Spring 的开发提供更快的入门体验。\r\n- 开箱即用，没有代码生成，也无需 XML 配置。同时也可以修改默认值来满足特定的需求。\r\n- 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。\r\n- Spring Boot 不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式。\r\n\r\n### Spring Boot 的核心功能\r\n\r\n- **起步依赖：**\r\n    - 起步依赖本质上是一个 Maven 项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。\r\n    - 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\r\n- **自动配置：**\r\n    - Spring Boot 的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定 Spring 配置应该用哪个，不该用哪个。该过程是 Spring 自动完成的。', 'https://images.pexels.com/photos/33227/sunrise-phu-quoc-island-ocean.jpg', '原创', 0, 0, 0, NULL, 1, 1, '2020-07-22 03:35:33', '2020-07-23 04:54:40', 'Spring Boot 对 Spring 的缺点进行改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。');
INSERT INTO `blog` VALUES (2, 2, 1, 'Spring概述', '# Spring 概述\r\n\r\n## 什么是 Spring\r\n\r\n- Spring 是分层的 Java SE/EE 应用 **full-stack** 轻量级开源框架，以 **IoC（InverseOfControl，反转控制）**和 **AOP（AspectOrientedProgramming，面向切面编程）**为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。\r\n\r\n## Spring 的优势\r\n\r\n- **方便解耦，简化开发**\r\n    - 通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。\r\n- **AOP 编程的支持**\r\n    - 通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付。\r\n- **声明式事务的支持**\r\n    - 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。\r\n- **方便程序的测试**\r\n    - 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。\r\n- **方便集成各种优秀框架**\r\n    - Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持。\r\n- **降低 JavaEE API 的使用难度**\r\n    - Spring 对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。\r\n- **Java 源码是经典学习范例**\r\n    - Spring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无疑是 Java 技术的最佳实践的范例。', 'https://images.pexels.com/photos/1576739/pexels-photo-1576739.jpeg?', '原创', 0, 1, 1, 1, 1, 1, '2020-07-22 03:41:45', '2020-07-23 02:51:38', 'Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（反转控制）和 AOP（面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。');
INSERT INTO `blog` VALUES (3, 5, 1, '数据库基础', '# 数据库概述\r\n\r\n1. 数据库的英文单词：\r\n    - DataBase（简称 DB）。\r\n2. 什么是数据库？\r\n    - 用于存储和管理数据的仓库。\r\n3. 数据库的特点：\r\n    1. 持久化存储数据。其实数据库就是一个文件系统。\r\n    2. 方便存储和管理数据。\r\n    3. 使用了统一的方式操作数据库（SQL）。\r\n4. 常见的数据库软件：\r\n    1. Oarcle\r\n    2. MySQL\r\n    3. Microsoft SQL Server\r\n5. 几个概念：\r\n    1. 数据库：相当于文件夹\r\n    2. 表：相当于文件\r\n    3. 数据记录：文件中存储的数据\r\n\r\n# 数据库基础\r\n\r\n## SQL 概述\r\n\r\n1. 什么是 SQL？\r\n\r\n    - Structured Query Language，结构化查询语言。\r\n    - 定义了操作所有关系型数据库的规则。\r\n    - 不同的数据库软件操作数据库的方式存在不一样的地方，类似“方言”。\r\n\r\n2. SQL 通用语法：\r\n\r\n    1. SQL 语句可以单行或多行书写，以分号结尾。\r\n    2. 可使用空格和缩进来增强语句的可读性。\r\n    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\r\n    4. 3 种注释：\r\n\r\n      - 单行注释:：`-- 注释内容` 或 `# 注释内容`（MySQL 特有）\r\n      - 多行注释：`/* 注释 */` \r\n\r\n3. SQL 分类：\r\n\r\n    1. DDL（Data Definition Language）数据定义语言\r\n        - 用来定义数据库对象：数据库，表，列等。\r\n        - 关键字：`create`，`drop`，`alter` 等。\r\n    2. DML（Data Manipulation Language）数据操作语言\r\n        - 用来对数据库中表的数据进行增删改。\r\n        - 关键字：`insert`，`delete`，`update` 等。\r\n    3. DQL（Data Query Language）数据查询语言\r\n        - 用来查询数据库中表的记录。\r\n        - 关键字：`select`，`where` 等。\r\n    4. DCL（Data Control Language）数据控制语言\r\n        - 用来定义数据库的访问权限和安全级别及创建用户。\r\n        - 关键字：`grant`，`revoke` 等。', 'https://images.pexels.com/photos/3607934/pexels-photo-3607934.jpeg', '原创', 0, 0, 0, 1, 1, 1, '2020-07-23 04:59:20', '2020-07-23 04:59:20', '数据库，英文单词 DataBase（简称 DB），是用于存储和管理数据的仓库。');
INSERT INTO `blog` VALUES (4, 6, 1, 'Java基础', '---\r\ntitle: Java基础\r\ndate: 2020-01-10 11:19:01\r\nid: java-fundamentals\r\ncategories:\r\n	- JavaSE\r\n	- Java基础\r\ntags:\r\n	- JavaSE\r\n	- Java基础\r\nmathjax: \r\n\r\n---\r\n\r\n# Java 概述\r\n\r\n##  Java 语言\r\n\r\nJava 语言是美国 Sun 公司（Stanford University Network），在 1995 年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。\r\n\r\n## Java 虚拟机\r\n\r\n**JVM（Java Virtual Machine）**：Java 虚拟机，简称 JVM，是运行所有 Java 程序的假想计算机，是 Java 程序的运行环境，是 Java 最具吸引力的特性之一。我们编写的 Java 代码，都运行在 JVM 之上。\r\n\r\n**跨平台**：任何软件的运行，都必须要运行在操作系统之上，而我们用 Java 编写的软件可以运行在任何的操作系统上，这个特性称为 Java 语言的跨平台特性。该特性是由 JVM 实现的，我们编写的**程序运行在 JVM 上，而  JVM 运行在操作系统上**。\r\n\r\n## JRE 和 JDK\r\n\r\n**JRE (Java Runtime Environment)**：是 Java 程序的运行时环境，包含 JVM 和运行时所需要的核心类库。\r\n\r\n**JDK (Java Development Kit)**：是 Java 程序开发工具包，包含 JRE 和开发人员使用的工具。\r\n\r\n# Java 入门\r\n\r\n## Java 程序开发\r\n\r\nJava程序开发三步骤：**编写、编译、运行**\r\n\r\n1. 编写 Java 源程序（后缀名 `.java`）\r\n2. 编译 Java 源文件（使用 `javac` 命令编译源程序为**字节码文件**，文件后缀 `.class`）\r\n3. 运行（使用 `java` 命令在 JVM 上运行字节码文件）\r\n\r\n编译和运行的区别\r\n\r\n- **编译**：是指将我们编写的 Java 源文件翻译成 JVM 认识的 class 文件，在这个过程中， javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。\r\n- **运行**：是指将 class 文件交给 JVM 去运行，此时 JVM 就会去执行我们编写的程序了。\r\n\r\n关于 **`main` 方法**\r\n\r\n- main 方法，也称为主方法，是程序的入口或起点。\r\n- JVM 在运行的时候，都会从 main 方法开始执行。\r\n\r\n## 注释\r\n\r\n**注释**：就是对代码的解释和说明，其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须要的，它不影响程序的编译和运行。\r\n\r\n- 单行注释：`//开头，换行结束` \r\n- 多行注释：`/*开头，*/结束` \r\n\r\n## 关键字\r\n\r\n**关键字**：是指在 Java 程序中事先定义好的单词，具有特殊意义。\r\n\r\n- 完全小写的字母\r\n- 在增强版的记事本中（如 notepad++）具有特殊颜色\r\n\r\n## 标识符\r\n\r\n**标识符**：是指在程序中，我们自己定义的内容，比如类的名字、方法的名字和变量的名字等等。\r\n\r\n**命名规则：`硬性要求`** \r\n\r\n- 标识符可以包含 `英文字母26个（区分大小写）` 、 `0-9数字` 、 `$（美元符号）` 和 `_（下划线）` \r\n- 标识符不能以数字开头\r\n- 标识符不能是关键字\r\n\r\n**命名规范：`软性建议`** \r\n\r\n- 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。\r\n- 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。\r\n- 变量名规范：同方法名。\r\n\r\n## 常量\r\n\r\n**常量**：Java 程序中固定不变的量\r\n\r\n| 类型       | 含义                                     | 数据举例                 |\r\n| ---------- | ---------------------------------------- | ------------------------ |\r\n| 整型常量   | 所有的整数                               | 0，1，100，-250          |\r\n| 小数常量   | 所有的小数                               | 0.0，2.5，-3.14          |\r\n| 字符常量   | 单引号引起来，只能写一个字符，必须有内容 | \'A\'，\'b\'，\'9\'，\'好\'，\' \' |\r\n| 字符串常量 | 双引号引起来，可以写多个字符，也可以不写 | \"A\"， \"Hello\"，\"123\"，\"\" |\r\n| 布尔常量   | 只有两个值                               | true，false              |\r\n| 空常量     | 只有一个值                               | null                     |\r\n\r\n## 数据类型\r\n\r\nJava 的数据类型分为两大类：\r\n\r\n- **基本数据类型**：包括 `整数` 、 `浮点数` 、 `字符` 、 `布尔`  \r\n- **引用数据类型**：包括 `字符串` 、 `数组` 、 `类` 、 `接口` 、 `Lambda` \r\n\r\n基本数据类型（4 类 8 种）\r\n\r\n| 数据类型     | 关键字         | 内存占用 | 取值范围                |\r\n| ------------ | -------------- | -------- | ----------------------- |\r\n| 字节型       | byte           | 1 个字节 | -128 ~ 127              |\r\n| 短整型       | short          | 2 个字节 | -32768 ~ 32767          |\r\n| 整型         | int（默认）    | 4 个字节 | -2^31 ~ 2^31-1          |\r\n| 长整型       | long           | 8 个字节 | -2^63 ~ 2^63-1          |\r\n| 单精度浮点型 | float          | 4 个字节 | 1.4013E-45 ~ 3.4028E+38 |\r\n| 双精度浮点型 | double（默认） | 8 个字节 | 4.9E-324 ~ 1.7977E+308  |\r\n| 字符型       | char           | 2 个字节 | 0 ~ 65535               |\r\n| 布尔型       | boolean        | -        | true，false             |\r\n\r\n注意事项：\r\n\r\n1. 字符串不是基本类型，而是引用类型。\r\n2. 浮点型可能只是一个近似值，并非精确的值。\r\n3. **数据范围与字节数不一定相关**，例如 float 数据范围比 long 更加广泛，但是 float 是4字节，long 是 8 字节。\r\n4. 浮点数当中默认类型是 double。如果一定要使用 float 类型，需要加上一个**后缀 F**。如果是整数，默认为 int 类型，如果一定要使用 long 类型，需要加上一个**后缀 L**。推荐使用大写字母后缀。\r\n\r\n## 变量\r\n\r\n**变量**：程序运行期间，内容可以发生改变产生的量。\r\n\r\nJava 中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。\r\n\r\n创建和使用变量的格式：\r\n\r\n```java\r\n1. 数据类型 变量名称; // 创建了一个变量\r\n   变量名称 = 数据值; // 赋值，将右边的数据值赋值给左边的变量\r\n\r\n2. 数据类型 变量名称 = 数据值; // 在创建变量的同时，立刻放入指定的数据值\r\n\r\n3. 变量1 = 变量2; // 将一个变量2的数据内容，赋值交给变量1\r\n```\r\n\r\n注意事项：\r\n\r\n1. 如果创建多个变量，那么变量之间的名称不可以重复。\r\n2. 对于 float 和 long 类型来说，字母后缀 F 和 L 不要丢掉。\r\n3. 如果使用 byte 或者 short 类型的变量，那么右侧的数据值不能超过左侧类型的范围。\r\n4. **没有进行赋值的变量，不能直接使用**；一定要赋值之后，才能使用。\r\n5. 变量使用不能超过作用域的范围。\r\n    **作用域**：从定义变量的一行开始，一直到直接所属的大括号结束为止。\r\n6. 可以通过一个语句来创建多个变量，但是一般情况不推荐这么写。\r\n\r\n# 数据类型转换\r\n\r\nJava 程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果**数据类型不一致将发生类型转换**。\r\n\r\n## 自动类型转换（隐式）\r\n\r\n- 特点：代码不需要进行特殊处理，自动完成。\r\n- 规则： `数据范围小的类型` 向 `数据范围大的类型` 提升。\r\n\r\n```java\r\nbyte/short/char --> int --> long --> float --> double\r\n```\r\n\r\n## 强制类型转换（显式）\r\n\r\n- 特点：代码需要进行特殊的格式处理，不能自动完成。\r\n- 规则：将 `数据范围大的类型` 强制转换成 `数据范围小的类型` 。\r\n\r\n```java\r\n范围小的类型 范围小的变量名 = (范围小的类型) 原本的范围大的数据值\r\n```\r\n\r\n注意事项：\r\n\r\n1. 强制类型转换一般不推荐使用，因为有可能发生**精度损失、数据溢出**。\r\n2. byte / short / char 这三种类型都可以发生数学运算，例如加法 \"+\"。在运算的时候，都会被**首先提升成为 int 类型**，然后再计算。\r\n3. boolean 类型不能发生数据类型转换。\r\n\r\n## ASCII & Unicode 编码表\r\n\r\n**编码表** ：数字和字符的对照关系表，就是将人类的文字和一个十进制数进行对应起来组成的一张表格。\r\n\r\n- ASCII 码表：American Standard Code for Information Interchange，美国信息交换标准代码。\r\n- Unicode 码表：万国码，开头 0-127 部分和 ASCII 完全一样，但是从 128 开始包含有更多字符。\r\n\r\n# 运算符 & 表达式\r\n\r\n运算符：进行特定操作的符号。\r\n\r\n表达式：用运算符连起来的式子。\r\n\r\n## 算术运算符\r\n\r\n| 算术运算符 | 作用                       |\r\n| ---------- | -------------------------- |\r\n| `+`        | 加法运算，字符串连接运算   |\r\n| `-`        | 减法运算                   |\r\n| `*`        | 乘法运算                   |\r\n| `/`        | 除法运算（整数相除只看商） |\r\n| `%`        | 取模运算（整数相除取余数） |\r\n| `++` `--`  | 自增和自减运算             |\r\n\r\n注意事项：\r\n\r\n1. 整数使用上述运算符的结果只会是整数。\r\n2. 一旦运算当中有不同类型的数据，那么结果将会是数据类型范围大的那种。\r\n\r\n运算符 `+` 的用法：\r\n\r\n- 对数值来说，就是加法；\r\n- 对字符 `char` 类型来说，计算之前先被提升为 `int` ；\r\n- 对字符串 `String` 来说，加号代表**字符串连接**操作，任何数据类型与字符串进行连接的结果都是字符串。\r\n\r\n运算符 `++` 的用法：\r\n\r\n- 基本含义：变量自己增长 1 \r\n- 使用格式：写在变量名称之前，或写在变量名称之后\r\n- 使用方式：\r\n    1. 单独使用：不和其他任何操作混合，自己独立成为一个步骤。此时 `前++` 和 `后++` 没有区别。\r\n    2. 混合使用：与其他操作混合。如果是前++，那么变量马上加 1，然后拿着结果进行使用；如果是后++，那么首先使用变量本来的值，然后再加 1。\r\n- 注意：只有变量才能使用自增和自减运算，常量不可发生改变。\r\n\r\n## 赋值运算符\r\n\r\n| 赋值运算符 | 作用         |\r\n| ---------- | ------------ |\r\n| `=`        | 基本赋值运算 |\r\n| `+=`       | 加等于       |\r\n| `-=`       | 减等于       |\r\n| `*=`       | 乘等于       |\r\n| `/=`       | 除等于       |\r\n| `%=`       | 取模等       |\r\n\r\n基本赋值运算：是将等号右边的值，赋值给等号左边的变量\r\n\r\n复合赋值运算：将等号右边的值进行复合操作后，赋值给等号左边的变量\r\n\r\n注意事项：\r\n\r\n1. 只有变量才能使用赋值运算符，常量不能进行赋值。\r\n2. **复合赋值运算符其中隐含了一个强制类型转换。**\r\n\r\n## 比较运算符\r\n\r\n| 比较运算符 | 作用     |\r\n| ---------- | -------- |\r\n| `==`       | 等于     |\r\n| `<`        | 小于     |\r\n| `>`        | 大于     |\r\n| `<=`       | 小于等于 |\r\n| `>=`       | 大于等于 |\r\n| `!=`       | 不等于   |\r\n\r\n比较运算：是两个数据之间进行比较的运算，运算结果都是布尔值 `true` 和 `false` 。\r\n\r\n注意事项：如果进行多次判断，不能像数学中一样连着写。\r\n\r\n## 逻辑运算符\r\n\r\n| 逻辑运算符           | 作用                                               |\r\n| -------------------- | -------------------------------------------------- |\r\n| `&&` （与）          | 全都是 true 才是 true，否则就是 false              |\r\n| &#124; &#124; （或） | 至少一个是 true 就是 true，全都是 false 才是 false |\r\n| `!` （非）           | 本来是 true 变成 false，本来是 false 变成 true     |\r\n\r\n注意事项：\r\n\r\n1. 逻辑运算符只能用于 boolean 值。\r\n2. 与、或需要左右各自有一个 boolean 值，但是取反只要有唯一的一个 boolean 值即可。\r\n3. 与、或两种运算符，如果有多个条件，可以连续写 `条件A && 条件B && 条件C` 。\r\n4. 与“&&”，或“||”，具有**短路**效果：如果根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，从而节省一定的性能。\r\n\r\n## 三元运算符\r\n\r\n三元运算符格式：\r\n\r\n```java\r\n数据类型 变量名称 = 布尔类型表达式 ? 表达式A : 表达式B\r\n```\r\n\r\n流程：\r\n\r\n- 如果布尔表达式成立（为 true），那么将表达式 A 的值赋值给左侧的变量；\r\n- 如果布尔表达式不成立（为 false），那么将表达式 B 的值赋值给左侧的变量。\r\n\r\n注意事项：\r\n\r\n1. 必须同时保证表达式 A 和表达式 B 都符合左侧数据类型的要求。\r\n2. **三元运算符的结果必须被使用**。\r\n\r\n# 方法入门\r\n\r\n## 方法概述\r\n\r\n**方法**：就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。当我们需要这个功能的时候，就可以去调用。这样即实现了**代码的复用性**，也**解决了代码冗余的现象**。\r\n\r\n## 方法的定义\r\n\r\n方法定义格式：\r\n\r\n```java\r\n修饰符 返回值类型 方法名(参数列表) {\r\n    方法体;\r\n}\r\n```\r\n\r\n- 方法名：方法名称的命名规则和变量一样，使用小驼峰。\r\n- 方法体：也就是大括号当中可以包含任意条语句。\r\n\r\n注意事项：\r\n\r\n- 方法定义的先后顺序无所谓\r\n- 方法的定义不能产生嵌套关系\r\n\r\n## 方法的调用\r\n\r\n方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法 main 中来调用我们自己定义好的方法。\r\n\r\n在主方法中，直接写要调用的方法名字就可以调用了，格式如下：\r\n\r\n```java\r\n方法名(实参);\r\n```\r\n\r\n# 流程控制\r\n\r\n在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说，程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。\r\n\r\n## 顺序结构\r\n\r\n顺序结构：按照编写的顺序，依次运行。\r\n\r\n```flow\r\nst=>start: 开始\r\ne=>end: 结束\r\nop1=>operation: 步骤1\r\nop2=>operation: 步骤2\r\nopdots=>operation: ...\r\nopn=>operation: 步骤n\r\nst->op1->op2->opdots->opn->e\r\n```\r\n\r\n## 分支（选择）结构\r\n\r\n### 判断语句（`if`）\r\n\r\n#### `if` 语句\r\n\r\n```java\r\nif (关系表达式) {\r\n    语句体;\r\n}\r\n```\r\n\r\n```flow\r\nop1=>operation: 其他语句\r\ncond=>condition: 关系表达式\r\nop2=>operation: 语句体\r\nop3=>operation: 其他语句\r\nop1->cond\r\ncond(yes)->op2->op3\r\ncond(no)->op3\r\n```\r\n\r\n#### `if-else` 语句\r\n\r\n```java\r\nif (关系表达式) {\r\n    语句体1;\r\n} else {\r\n    语句体2;\r\n}\r\n```\r\n\r\n```flow\r\nop1=>operation: 其他语句\r\nop2=>operation: 其他语句\r\ncond=>condition: 关系表达式\r\nop3=>operation: 语句体1\r\nop4=>operation: 语句体2\r\nop1->cond\r\ncond(yes)->op3->op2\r\ncond(no)->op4->op2\r\n```\r\n\r\n#### `if-else if-else` 语句\r\n\r\n```java\r\nif (判断条件1) {\r\n    语句体1;\r\n} else if (判断条件2) {\r\n    语句体2;\r\n}\r\n...\r\n} else if (判断条件n) {\r\n    语句体n;\r\n} else {\r\n    语句体n+1;\r\n}\r\n```\r\n\r\n```flow\r\nst=>operation: 其他语句\r\ne=>operation: 其他语句\r\ncond1=>condition: 判断条件1\r\ncond2=>condition: 判断条件2\r\nconddots=>condition: ……\r\ncondn=>condition: 判断条件n\r\nop1=>operation: 语句体1\r\nop2=>operation: 语句体2\r\nopdots=>operation: ……\r\nopn=>operation: 语句体n\r\nopn+1=>operation: 语句体n+1\r\nst->cond1\r\ncond1(yes)->op1->e\r\ncond1(no)->cond2\r\ncond2(yes)->op2->e\r\ncond2(no)->conddots\r\nconddots(yes)->opdots->e\r\nconddots(no)->condn\r\ncondn(yes)->opn->e\r\ncondn(no)->opn+1->e\r\n```\r\n\r\n### 选择语句（`switch`）\r\n\r\n `switch` 语句格式：\r\n\r\n```java\r\nswitch(表达式) {\r\n    case 常量值1:\r\n        语句体1;\r\n        break;\r\n    case 常量值2:\r\n        语句体2;\r\n        break;\r\n    ...\r\n    default:\r\n        语句体n+1;\r\n        break;\r\n}\r\n```\r\n\r\n```flow\r\nst=>operation: 其他语句\r\ne=>operation: 其他语句\r\ncond1=>condition: 表达式=常量值1\r\ncond2=>condition: 表达式=常量值2\r\nconddots=>condition: ......\r\nop1=>operation: 语句体1\r\nop2=>operation: 语句体2\r\nopdots=>operation: ......\r\nopn+1=>operation: 语句体n+1\r\nst->cond1\r\ncond1(yes)->op1->e\r\ncond1(no)->cond2\r\ncond2(yes)->op2->e\r\ncond2(no)->conddots\r\nconddots(yes)->opdots->e\r\nconddots(no)->opn+1->e\r\n```\r\n\r\n注意事项：\r\n\r\n1. 多个 case 后面的数值不可以重复。\r\n2. switch 后面小括号当中只能是下列数据类型：\r\n    - 基本数据类型：`byte` 、 `short` 、 `char` 、 `int`\r\n    - 引用数据类型：`String` 、 `enum` \r\n3. switch 语句格式可以很灵活：前后顺序可以颠倒，而且 break 语句还可以省略。**匹配哪一个 case 就从哪一个位置向下执行，直到遇到了 break 或者整体结束为止。**\r\n\r\n## 循环结构\r\n\r\n循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为 false，从而结束循环，否则循环将一直执行下去，形成死循环。\r\n\r\n循环结构的基本组成部分，一般可以分成四部分：\r\n\r\n1. **初始化语句**：在循环开始最初执行，而且只做唯一一次。\r\n2. **条件判断**：如果成立，则循环继续；如果不成立，则循环退出。\r\n3. **循环体**：重复要做的事情内容，若干行语句。\r\n4. **步进语句**：每次循环之后都要进行的扫尾工作，每次循环结束之后都要执行一次。\r\n\r\n###  `for` 循环\r\n\r\n `for` 循环语句格式：\r\n\r\n```java\r\nfor(初始化表达式; 布尔表达式; 步进表达式) {\r\n    循环体;\r\n}\r\n```\r\n\r\n```flow\r\nst=>operation: 其他语句\r\ne=>operation: 其他语句\r\nop1=>operation: 初始化语句\r\ncond=>condition: 条件判断语句\r\nop2=>operation: 循环体语句\r\nop3=>operation: 步进语句\r\nst->op1->cond\r\ncond(yes)->op2->op3(left)->cond\r\ncond(no)->e\r\n```\r\n\r\n###  `while` 循环\r\n\r\n `while` 循环语句格式：\r\n\r\n```java\r\n初始化语句;\r\nwhile(布尔表达式) {\r\n    循环体;\r\n    步进语句;\r\n}\r\n```\r\n\r\n```flow\r\nst=>operation: 其他语句\r\ne=>operation: 其他语句\r\nop1=>operation: 初始化语句\r\ncond=>condition: 条件判断语句\r\nop2=>operation: 循环体语句\r\nop3=>operation: 步进语句\r\nst->op1->cond\r\ncond(yes)->op2->op3(left)->cond\r\ncond(no)->e\r\n```\r\n\r\n###  `do-while` 循环\r\n\r\n `do while` 循环语句格式：\r\n\r\n```java\r\n初始化语句;\r\ndo {\r\n    循环体;\r\n    步进语句;\r\n}while(布尔表达式);\r\n```\r\n\r\n```flow\r\nst=>operation: 其他语句\r\ne=>operation: 其他语句\r\nop1=>operation: 初始化语句\r\ncond=>condition: 条件判断语句\r\nop2=>operation: 循环体语句\r\nop3=>operation: 步进语句\r\nst->op1->op2->op3->cond\r\ncond(yes)->op2\r\ncond(no)->e\r\n```\r\n\r\n `do-while` 循环的特点：**无条件执行一次循环体**，即使我们将循环条件直接写成 false，也依然会循环一次。这样的循环具有一定的风险性。\r\n\r\n### 三种循环的区别\r\n\r\n1. 如果条件判断从来没有满足过，那么 for 循环和 while 循环将会执行 0 次，但是 do-while 循环会执行至少一次。\r\n2. for 循环的变量在小括号当中定义，只有循环内部才可以使用。while 循环和 do-while 循环初始化语句本来就在循环外定义变量，所以出来循环结束后还可以继续使用。\r\n\r\n### 跳出语句\r\n\r\n###  `break` 语句\r\n\r\n使用场景：终止 `switch` 或循环\r\n\r\n1. 可以用在 switch 语句当中，一旦执行，整个 switch 语句立刻结束。\r\n2. 还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。\r\n\r\n###  `continue` 语句\r\n\r\n使用场景：结束本次循环，继续下一次循环\r\n\r\n### 死循环\r\n\r\n永远停不下来的循环，叫做死循环。\r\n\r\n死循环的标准格式：\r\n\r\n```java\r\nwhile (true) {\r\n    循环体;\r\n}\r\n```\r\n\r\n### 循环嵌套\r\n\r\n所谓嵌套循环，是指一个循环的循环体内包含另一个循环。比如 for 循环里面还有一个 for 循环，就是嵌套循环。\r\n\r\n `总共的循环次数 = 外循环次数 * 内循环次数` 。\r\n\r\n# 方法\r\n\r\n方法（Method）就是若干语句的功能集合。\r\n\r\n## 定义方法\r\n\r\n定义方法的格式：\r\n\r\n```java\r\n修饰符 返回值类型 方法名(参数类型 参数名, ...) {\r\n    方法体;\r\n    [return 返回值;]\r\n}\r\n```\r\n\r\n- 当一个方法需要一些数据条件，才能完成任务的时候，就有参数。\r\n- 一个方法不需要任何数据条件，自己就能独立完成任务，就无参数。\r\n- 返回值类型：必须要和 return 语句返回值的类型相同，否则编译失败 。\r\n- 不能在 return 后面写代码，return 意味着方法结束，所有后面的代码永远不会执行，属于无效代码。\r\n\r\n## 调用方法\r\n\r\n方法的三种调用格式：\r\n\r\n1. 单独调用： `方法名(参数);` \r\n2. 打印调用： `System.out.println(方法名(参数));`\r\n3. 赋值调用： `数据类型 变量名 = 方法名(参数);` \r\n\r\n注意：返回值类型为 void 的方法只能单独调用，不能进行打印调用和赋值调用\r\n\r\n## 注意事项\r\n\r\n1. 方法应该定义在类当中，但是不能在方法当中再定义方法。\r\n2. 方法定义的前后顺序无所谓。\r\n3. 方法定义之后不会执行，如果希望执行，一定要调用。\r\n4. 如果方法有返回值，那么必须写上 `return 返回值;` ，不能没有。\r\n5. return 后面的返回值数据，必须和方法的返回值类型，对应起来。\r\n6. 对于一个 void 方法，不能写 return 后面的返回值，只能写 `return;` 。\r\n7. 对于 void 方法当中最后一行的 return 可以省略不写。\r\n8. 一个方法当中可以有多个 return 语句，但是必须保证同时只有一个会被执行到，两个 return 不能连写。\r\n\r\n## 方法重载\r\n\r\n**方法重载（Overload）**：指在同一个类中，允许存在一个以上的**同名方法**，只要它们的**参数列表不同**即可，**与参数名称、修饰符和返回值类型无关**。\r\n\r\n- 好处：只需要记住唯一一个方法名称，就可以实现类似的多个功能。\r\n- 参数列表：**个数**不同，**数据类型**不同，**多类型顺序**不同。\r\n- 重载方法调用：JVM 通过方法的参数列表，调用不同的方法。\r\n\r\n# 数组\r\n\r\n## 数组概念\r\n\r\n数组的概念：是一种容器，可以同时存放多个数据值。\r\n\r\n数组的特点：\r\n\r\n1. 数组是一种引用数据类型\r\n2. 数组当中的多个数据，类型必须统一\r\n3. **定长**特性：数组的长度在程序运行期间不可改变\r\n\r\n## 数组的初始化\r\n\r\n数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值。\r\n\r\n两种常见的初始化方式：\r\n\r\n1. 动态初始化（指定长度）\r\n2. 静态初始化（指定内容）\r\n\r\n### 动态初始化数组\r\n\r\n动态初始化数组的格式：\r\n\r\n```java\r\n数据类型[] 数组名 = new 数据类型[数组长度];\r\n```\r\n\r\n使用动态初始化数组时，其中的元素将在自动拥有一个默认值。规则如下：\r\n\r\n- 如果是整数类型，默认值为 `0` \r\n- 如果是浮点数类型，默认值为 `0.0` \r\n- 如果是字符类型，默认值为 `\\u0000` （不可见字符）\r\n- 如果是布尔类型，默认值为 `false` \r\n- 如果是引用类型，默认值为 `null` \r\n\r\n### 静态初始化数组\r\n\r\n静态初始化数组的格式：\r\n\r\n```java\r\n数据类型[] 数组名 = new 数据类型[] {元素1,元素2, 元素3, ...};	// 标准格式\r\n\r\n数据类型[] 数组名 = {元素1,元素2, 元素3, ...};	// 省略格式\r\n```\r\n\r\n注意事项：\r\n\r\n1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度。\r\n2. 动态初始化和静态初始化标准格式可以拆分成为 `声明数组` 和 `创建数组` 两个步骤。\r\n3. 静态初始化一旦使用省略格式，就不能拆分成为两个步骤来写了，但依然隐含了 new 操作。\r\n\r\n## 数组元素的访问\r\n\r\n**数组索引**： 每一个存储到数组的元素，都会自动的拥有一个编号， `从 0 开始，一直到数组长度减 1 为止` ，这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素。\r\n\r\n访问数组元素的格式：\r\n\r\n```java\r\n数组名[索引]\r\n```\r\n\r\n索引访问数组中的元素：\r\n\r\n- `数组名[索引] = 数据值` ，为数组中的元素赋值\r\n- `变量名 = 数组名[索引]` ，获取出数组中的元素\r\n\r\n## 数组的内存原理\r\n\r\n内存是用于程序运行的临时存储区域，程序运行完毕后会清空内存。\r\n\r\nJava 虚拟机为了提高运算效率，对内存空间进行了不同区域的划分：\r\n\r\n| 区域名称                          | 作用                                        |\r\n| --------------------------------- | ------------------------------------------- |\r\n| 寄存器（PC Register）             | 与 CPU 相关                                 |\r\n| 本地方法栈（Native Method Stack） | JVM 在使用操作系统功能的时候使用            |\r\n| 方法区（Method Area）             | 存储 .class 文件，包含方法的信息            |\r\n| 堆（Heap）                        | 存储对象或数组，凡是 new 创建的都存储在堆中 |\r\n| 栈（Stack）                       | 存储方法中的局部变量，方法一定在栈中运行    |\r\n\r\n数组名称：存储数组**内存地址哈希值**。\r\n\r\n `数组A = 数组B` 将数组 A 的引用赋值给数组 B，结果数组 A 和 B 将会指向同一片内存空间。\r\n\r\n有两个独立数组的内存图如下：\r\n\r\n![](Java基础\\有两个独立数组的内存图.png)\r\n\r\n## 数组操作的常见异常\r\n\r\n### 数组越界异常\r\n\r\n如果访问数组元素的时候，索引编号并不存在，程序运行后，将会抛出 `ArrayIndexOutOfBoundsException` 数组越界异常。\r\n\r\n### 数组空指针异常\r\n\r\n所有的引用类型变量，都可以赋值为一个 null 值，但是代表其中什么都没有。\r\n\r\n数组必须进行 new 初始化才能使用其中的元素。如果只是赋值了一个 null，没有进行 new 创建，那么将会发生 `NullPointerException` 空指针异常。\r\n\r\n## 数组的长度\r\n\r\n每个数组都具有长度，而且是固定的。\r\n\r\nJava 中赋予了数组的一个属性，可以获取到数组的长度，语句为： `数组名.length` ，属性 length 的执行结果是数组的长度，int 类型结果。\r\n\r\n数组一旦创建，程序运行期间，长度不可改变。\r\n\r\n## 遍历数组\r\n\r\n数组遍历： 将数组中的每个元素分别获取出来，就是遍历。\r\n\r\n遍历也是数组操作中的基石。\r\n\r\n数组的索引是 `0` 到 `lenght-1` ，可以作为循环的条件出现。\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n	int[] array = { 1, 2, 3, 4, 5 };\r\n	for (int i = 0; i < array.length; i++) {\r\n		System.out.println(array[i]);\r\n	}\r\n}\r\n```\r\n\r\n## 数组作为方法参数和返回值\r\n\r\n一个方法**可以有0、1 或多个参数**；但是只能有0或者1个返回值，**不能有多个返回值**。\r\n\r\n任何数据类型都能作为方法的参数类型或返回值类型。\r\n\r\n- 数组作为方法参数传递，传递的参数是数组内存的地址。\r\n- 数组作为方法的返回值，返回的其实也是数组的地址值。\r\n\r\n## 方法的参数类型区别\r\n\r\n- **方法的参数为基本类型时，传递的是数据值。** \r\n- **方法的参数为引用类型时，传递的是地址值。** ', 'https://images.pexels.com/photos/1025469/pexels-photo-1025469.jpeg', '原创', 0, 1, 1, 1, 1, 1, '2020-07-23 05:02:13', '2020-07-23 05:02:13', 'Java 语言是美国 Sun 公司（Stanford University Network），在 1995 年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。');
INSERT INTO `blog` VALUES (5, 6, 1, 'Java面向对象', '---\r\ntitle: Java面向对象\r\ndate: 2020-01-15 15:13:22\r\nid: java-object-oriented\r\ncategories:\r\n	- JavaSE\r\n	- Java面向对象\r\ntags:\r\n	- JavaSE\r\n	- Java面向对象\r\nmathjax: \r\n\r\n---\r\n\r\n# 面向对象思想\r\n\r\n## 概述\r\n\r\nJava 语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用 Java 语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。\r\n\r\n面向对象思想就是在计算机程序设计过程中，参照现实中事物，**将属性特征、行为特征抽象出来，描述成计算机事件**的设计思想。 它区别于面向过程思想，**强调的是通过调用对象的行为来实现功能**，而不是自己一步一步的去操作实现。\r\n\r\n\r\n\r\n## 特点\r\n\r\n面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了**三大基本特征，即封装、继承和多态。**\r\n\r\n# 类和对象\r\n\r\n## 什么是类和对象\r\n\r\n**类**：是一组相关**属性**和**行为**的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。\r\n\r\n- **属性**：就是该事物的状态信息。\r\n- **行为**：就是该事物能够做什么。\r\n\r\n**对象**：是一类事物的具体体现。对象是**类的一个实例**，必然具备该类事物的属性和行为。\r\n\r\n类和对象的关系：\r\n\r\n- 类是对一类事物的描述，是**抽象**的。\r\n- 对象是一类事物的实例，是**具体**的。\r\n- **类是对象的模板，对象是类的实例。**\r\n\r\n## 类的定义\r\n\r\nJava 中用类（`class`） 来描述事物：\r\n\r\n- **成员变量**（属性）\r\n- **成员方法**（行为）\r\n\r\n类的定义格式：\r\n\r\n```java\r\npublic class ClassName {\r\n    // 成员变量\r\n    // 成员方法\r\n}\r\n```\r\n\r\n注意事项：\r\n\r\n1. 成员变量直接定义在**类中、方法外**；\r\n2. 成员方法**不加 static 关键字**。\r\n\r\n## 对象的使用\r\n\r\n通常情况下，一个类不能直接使用，需要根据类创建一个对象才能使用。\r\n\r\n创建对象：\r\n\r\n```java\r\nClassName objectName  = new ClassName();\r\n```\r\n\r\n使用对象访问类中的成员：\r\n\r\n```java\r\nobjectName.成员变量名\r\nobjectName.成员方法名(参数)\r\n```\r\n\r\n成员变量的默认值：\r\n\r\n| 数据类型                       | 默认值 |\r\n| ------------------------------ | ------ |\r\n| 整数（byte、short、int、long） | 0      |\r\n| 浮点数（float、double）        | 0.0    |\r\n| 字符（char）                   | \\u0000 |\r\n| 布尔（boolean）                | false  |\r\n| 引用（数组、类、接口）         | null   |\r\n\r\n## 对象内存原理\r\n\r\n- 创建的对象存储在堆内存中\r\n    - 成员变量\r\n    - 成员方法标记值（成员方法的地址值）\r\n- 类的信息存储在方法区中\r\n    - 成员方法的信息\r\n- 程序运行在栈内存中\r\n    - main 方法首先入栈，最后出栈\r\n        - 局部变量\r\n        - 引用变量（对象地址值）\r\n    - 成员方法不断压栈和出栈\r\n        - 局部变量\r\n\r\n只有一个对象的内存图如下：\r\n\r\n![](Java面向对象/只有一个对象的内存图.png)\r\n\r\n## 使用对象类型作为方法的参数和返回值\r\n\r\n引用类型作为参数和返回值时，传递的都是地址值。\r\n\r\n## 成员变量和局部变量的区别\r\n\r\n变量根据**定义位置的不同**分成成员变量和局部变量两种：\r\n\r\n```java\r\npublic class ClassName {\r\n    数据类型 成员变量名;	// 成员变量\r\n    public void methodName() {\r\n        数据类型 局部变量名;	// 局部变量\r\n    }\r\n}\r\n```\r\n\r\n- 在类中的位置不同\r\n    - 成员变量：类中、方法外\r\n    - 局部变量：方法中或者方法声明中（形式参数）\r\n- 作用范围不同\r\n    - 成员变量：类中\r\n    - 局部变量：方法中\r\n- 初始化值不同\r\n    - 成员变量：有默认值\r\n    - 局部变量：没有默认值，必须定义后赋值才能使用\r\n- 在内存中的位置不同\r\n    - 成员变量：堆内存\r\n    - 局部变量：栈内存\r\n- 生命周期不同\r\n    - 成员变量：随着对象的创建而存在，随着对象的消失而消失\r\n    - 局部变量：随着方法的调用而存在，随着方法调用完毕而消失\r\n\r\n# 封装\r\n\r\n## 概述\r\n\r\n面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。\r\n\r\n封装就是将一些细节信息隐藏起来，对于外界不可见。封装性在 Java 当中的体现：\r\n\r\n1.  `方法` 就是一种封装：调用者只知道方法会完成什么功能，并不知道功能具体是如何实现的。\r\n2.  关键字 `private` 也是一种封装：将类的属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。\r\n\r\n##  `private` 关键字\r\n\r\n `private` 的含义：\r\n\r\n- private 是一个**权限修饰符**，代表最小权限，可以修饰成员变量和成员方法。\r\n- 被 private 修饰后的成员变量和成员方法，**在本类当中仍可以随意访问**，但是超出了本类范围之外就不能再直接访问了。\r\n\r\n间接访问 private 成员变量：定义 `getXxx` 方法和 `setXxx` 方法\r\n\r\n- Getter 方法：不能有参数，返回值类型和成员变量对应\r\n- Setter 方法：不能有返回值，参数类型和成员变量对应\r\n- 对于基本类型当中的 boolean 值，Getter 方法一定要写成 `isXxx` 的形式，而 setXxx 规则不变\r\n\r\n## `this` 关键字\r\n\r\n当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，会优先使用局部变量，导致成员变量被隐藏，无法访问成员变量。\r\n\r\n如果需要访问本类当中的成员变量，需要使用 `this` 关键字。使用格式为：\r\n\r\n```java\r\nthis.成员变量名\r\n```\r\n\r\n使用 this 关键字代表所在类的当前对象的引用（地址值），即对象自己的引用。**谁在调用，谁就是this。** \r\n\r\n## 构造方法\r\n\r\n当我们**通过关键字 new 来创建对象时，其实就是在调用构造方法。**构造方法专门用来初始化对象，给对象的成员变量赋初始值。\r\n\r\n构造方法的格式：\r\n\r\n```java\r\npublic ClassName(参数类型 参数名称, ...) {\r\n    方法体;\r\n}\r\n```\r\n\r\n- 构造方法的名称必须与所在类的类名完全一致\r\n- 构造方法**没有返回值类型**，也不能返回一个值\r\n- 如果没有自定义构造方法，编译器会默认提供一个**无参构造方法** `public ClassName() {}` \r\n- 一旦自定义构造方法，编译器不再提供默认的无参构造方法\r\n- 构造方法可以重载\r\n\r\n## 标准的类（JavaBean）\r\n\r\n一个标准的类通常要满足下面的条件：\r\n\r\n1. 类是具体的和公共的；\r\n2. 所有的成员变量都使用 private 关键字修饰；\r\n3. 为每一个成员变量都提供一对 Getter/Setter 方法；\r\n4. 必须具有一个无参数的构造方法；\r\n5. 建议具有一个全参数的构造方法；\r\n\r\n这样的标准规范也叫做 `Java Bean` 规范，格式如下：\r\n\r\n```java\r\npublic class ClassName{\r\n    //成员变量\r\n    //构造方法，无参构造方法【必须】，有参构造方法【建议】\r\n    //成员方法\r\n    //getXxx()\r\n    //setXxx()\r\n}\r\n```\r\n\r\n# 继承\r\n\r\n多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。其中，多个类可以称为 **`子类`** ，单独那一个类称为 **`父类`** 、超类（superclass）或者基类。\r\n\r\n**继承**：就是子类继承父类的**属性和行为**，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。\r\n\r\n继承描述的是事物之间的所属关系，这种关系是 **`is-a`** 的关系。“子类就是一个父类”，也就是说，子类可以被当做父类看待。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。\r\n\r\n## `extends` 关键字\r\n\r\n通过 `extends` 关键字，可以声明一个子类继承另外一个父类，定义格式如下：\r\n\r\n```java\r\nclass 父类 {\r\n    ...\r\n}\r\n\r\nclass 子类 extends 父类 {\r\n    ...\r\n}\r\n```\r\n\r\n## 继承后的成员变量\r\n\r\n### 成员变量的访问\r\n\r\n在父子类的继承关系当中：\r\n\r\n- 如果成员变量**不重名**，这时的访问是没有影响的\r\n- 如果成员变量**重名**，则创建子类对象时，访问有两种方式：\r\n    - **直接**通过子类对象访问成员变量： `等号左边是谁，就优先用谁，没有则向上找。` \r\n    - **间接**通过成员方法访问成员变量： `该方法属于谁，就优先用谁，没有则向上找。` \r\n\r\n###  `super` 关键字\r\n\r\n当子类和父类中出现了同名的成员变量时，如果在子类中需要访问父类中非私有成员变量，需要使用 `super` 关键字修饰父类成员变量，类似于 `this` 。\r\n\r\n### 访问重名的三种变量\r\n\r\n访问重名的局部变量、本类成员变量和父类成员变量：\r\n\r\n- 局部变量： `直接写成员变量名` \r\n- 本类的成员变量： `this.成员变量名` \r\n- 父类的成员变量： `super.成员变量名` \r\n\r\n## 继承后的成员方法\r\n\r\n### 成员方法的调用\r\n\r\n在父子类继承关系中：\r\n\r\n- 如果成员方法不重名，这时的调用是没有影响的， `创建的对象是谁，就优先用谁，如果没有则向上找。` \r\n- 如果成员方法重名，这是的访问是一种特殊情况，叫做 **方法重写（Override）** 。\r\n\r\n### 方法重写\r\n\r\n**方法重写** ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果。即方法的**声明不变，重新实现。** \r\n\r\n- 特点：创建的是子类对象，则优先用子类方法。\r\n- 注意事项：\r\n    1. 必须保证父子类之间方法的名称相同，参数列表也相同； `@Override` \r\n    2. 子类方法的返回值必须**小于等于**父类方法的返回值范围；\r\n    3. 子类方法的权限必须**大于等于**父类方法的权限修饰符。 `public > protected > (default) > private` \r\n\r\n## 继承后的构造方法\r\n\r\n构造方法的格式和作用：\r\n\r\n- 构造方法是与类名一致的，所以子类无法继承父类的构造方法。\r\n- 构造方法是用来初始化成员变量的，所以在子类的初始化过程中，必须先执行父类的初始化动作。\r\n\r\n继承关系中，父子类构造方法的访问特点：\r\n\r\n1. 子类构造方法当中有一个默认隐含的 `super()` 调用，所以一定是先调用的父类构造方法，后执行的子类构造方法。\r\n2. 子类构造方法可以通过 `super` 关键字来调用父类重载的构造方法。\r\n3. super 的父类构造方法调用，必须是子类构造方法的第一个语句。\r\n4. 不能一个子类构造方法调用多次 super 构造方法。\r\n\r\n总结：子类构造方法必须调用父类构造方法，不写则隐含 super()；写了则调用写的指定的 super 调用。super 只能有一个，且必须是第一个。\r\n\r\n##  `super` 与 `this` \r\n\r\n### 父类空间优先于子类对象产生\r\n\r\n在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于**子类对象中包含了其对应的父类空间**，便可以包含其父类的成员，如果父类成员非 private 修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。\r\n\r\n-  `super`  ：代表父类的存储空间标识。\r\n-  `this`  ：代表当前对象的引用。\r\n\r\nsuper 与 this 的内存图示如下：\r\n\r\n![](Java面向对象/super与this的内存图.png)\r\n\r\n\r\n\r\n### 含义与用法总结\r\n\r\n `super` 关键字用来访问父类内容，用法有三种：\r\n\r\n1. 在子类的成员方法中，访问父类的成员变量。\r\n2. 在子类的成员方法中，访问父类的成员方法。\r\n3. 在子类的构造方法中，访问父类的构造方法。\r\n\r\n\r\n `this` 关键字用来访问本类内容，用法也有三种：\r\n\r\n1. 在本类的成员方法中，访问本类的成员变量。\r\n2. 在本类的成员方法中，访问本类的另一个成员方法。\r\n3. 在本类的构造方法中，访问本类的另一个构造方法。\r\n\r\n注意事项： `this(...)` 和 `super(...)` 调用都必须是构造方法的第一个语句，且是唯一一个，因此 super 和 this 两种构造方法调用不能同时使用。\r\n\r\n```java\r\npublic class Fu {\r\n	int num = 30;\r\n}\r\n\r\npublic class Zi extends Fu {\r\n    int num = 20;\r\n    \r\n    public Zi() {\r\n        // super(); // 这一行不再默认添加\r\n        this(123); // 本类的无参构造，调用本类的有参构造\r\n        // this(1, 2); // 错误写法！\r\n    }\r\n    \r\n    public Zi(int n) {\r\n        this(1, 2);\r\n    }\r\n    \r\n    public Zi(int n, int m) {\r\n        // 隐含super();\r\n    }\r\n\r\n    public void showNum() {\r\n        int num = 10;\r\n        System.out.println(num); // 局部变量\r\n        System.out.println(this.num); // 本类中的成员变量\r\n        System.out.println(super.num); // 父类中的成员变量\r\n    }\r\n\r\n    public void methodA() {\r\n        System.out.println(\"AAA\");\r\n    }\r\n\r\n    public void methodB() {\r\n        this.methodA();\r\n        System.out.println(\"BBB\");\r\n    }\r\n}\r\n```\r\n\r\n## 继承的特点\r\n\r\n1. 继承主要解决的问题是**`共性抽取`**。\r\n2. Java 只支持 **`单继承`** ，不支持多继承。一个类的直接父类只能有唯一一个。\r\n3. Java 支持 **`多级继承`** 。所有类都默认继承 `java.lang.Object` 类。\r\n4. 一个类的直接父类是唯一的，但是一个父类可以拥有多个子类。\r\n5. 子类可以拥有父类的内容，还可以拥有自己的专属内容。\r\n\r\n# 抽象类\r\n\r\n父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法体，只有声明还有意义，而方法体则没有存在的意义了。我们把**没有方法体的方法称为抽象方法**。Java语法规定，**包含抽象方法的类就是抽象类。** \r\n\r\n##  `abstract` 关键字\r\n\r\n抽象方法定义格式：\r\n\r\n```java\r\n修饰符 abstract 返回值类型 方法名();\r\n```\r\n\r\n抽象类定义格式：\r\n\r\n```java\r\n修饰符 abstract 类名 {\r\n    ...\r\n}\r\n```\r\n\r\n## 抽象方法和抽象类的使用\r\n\r\n如何使用抽象类和抽象方法：\r\n\r\n1. 不能直接创建 new 抽象类对象。\r\n2. 必须用一个子类来继承抽象父类。\r\n3. 子类必须重写抽象父类当中所有的抽象方法。\r\n4. 创建子类对象进行使用。\r\n\r\n继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。\r\n\r\n此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。\r\n\r\n## 注意事项\r\n\r\n1. 抽象类不能创建对象。\r\n2. 抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用的。\r\n3. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\r\n4. 抽象类的子类必须重写抽象父类中所有的抽象方法，否则该子类也是抽象类。\r\n\r\n# 接口\r\n\r\n## 接口概述\r\n\r\n接口就是**多个类的公共规范**，是一种**引用数据类型**。\r\n\r\n如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是**封装了方法**，包含`常量`、`抽象方法`（JDK 7 及以前）、`默认方法`、`静态方法`（JDK 8）、`私有方法` （JDK 9）。\r\n\r\n## 接口的定义\r\n\r\n接口的定义方式，与类的定义方式相似，但是使用 **`interface` 关键字**。它也会被编译成 .class 文件，但一定要明确它并不是类，而是另外一种引用数据类型。\r\n\r\n```java\r\npublic interface 接口名称 {\r\n    // 常量\r\n    // 抽象方法\r\n    // 默认方法\r\n    // 静态方法\r\n    // 私有方法\r\n}\r\n```\r\n\r\n### 含有抽象方法\r\n\r\n在任何版本的 Java 中，接口都能定义抽象方法，格式如下：\r\n\r\n```java\r\n[public] [abstract] 返回值类型 方法名称(参数列表);\r\n```\r\n\r\n注意事项：\r\n\r\n1. 接口当中的抽象方法，修饰符必须是两个固定的关键字： `public abstract` ；\r\n2. 这两个关键字修饰符，可以选择性地省略；\r\n3. 方法的三要素（方法名、返回值、参数列表）可以随意定义。\r\n\r\n```java\r\npublic interface MyInterfaceAbstract {\r\n    // 这是一个抽象方法\r\n    public abstract void methodAbs1();\r\n    // 这也是抽象方法\r\n    abstract void methodAbs2();\r\n    // 这也是抽象方法\r\n    public void methodAbs3();\r\n    // 这也是抽象方法\r\n    void methodAbs4();\r\n}\r\n```\r\n\r\n### 含有默认方法\r\n\r\n从 Java 8 开始，接口中允许定义**默认方法**，用来解决接口升级所导致的原有实现类未实现新添加抽象方法而报错的问题，为修改接口而不破坏原来的实现类的结构提供了便利。\r\n\r\n默认方法使用 **`default` 关键字**。\r\n\r\n```java\r\n[public] default 返回值类型 方法名称(参数列表) {\r\n    // 方法体\r\n}\r\n```\r\n\r\n- 实现类继承了接口的**默认方法，既可以直接调用，也可以重写**。\r\n- **一个声明在类里面的方法优先于任何默认方法**，优先选取最具体的实现。\r\n- 默认方法**不能重写 `Object` 中的方法，但是可以重载 `Object` 中的方法**。\r\n\r\n### 含有静态方法\r\n\r\n从 Java 8 开始，接口中允许声明**静态方法**，并且可以实现，用 **`static` 关键字**修饰。\r\n\r\n```java\r\n[public] static 返回值类型 方法名称(参数列表) {\r\n    // 方法体\r\n}\r\n```\r\n\r\n- 不能通过接口实现类的对象来调用接口中的静态方法。\r\n- 通过接口名称直接调用其中的静态方法，格式：`接口名称.静态方法名(参数);` \r\n\r\n### 含有私有方法\r\n\r\n当需要抽取一个共有方法用来解决多个默认方法或静态方法之间的重复代码问题时，这个共有方法不应该让实现类使用，应该是私有化的。\r\n\r\n从 Java 9 开始，接口当中允许定义**私有方法**，使用 **`private` 关键字**修饰。\r\n\r\n```java\r\nprivate [static] 返回值类型 方法名称(参数列表) {\r\n    // 方法体\r\n}\r\n```\r\n\r\n- 普通私有方法：解决多个默认方法之间重复代码问题，只有默认方法可以调用\r\n- 静态私有方法：解决多个静态方法之间重复代码问题，只有静态方法可以调用\r\n\r\n### 含有常量\r\n\r\n接口当中也可以定义“成员变量”，但是**默认使用 `public static final` 三个关键字进行修饰**。从效果上看，这其实就是接口的 **`常量`**，不可改变。\r\n\r\n```java\r\n[public] [static] [final] 数据类型 常量名称 = 数据值;\r\n```\r\n\r\n注意事项：\r\n\r\n1. 接口当中的常量可以省略 public static final。\r\n2. 接口当中的常量**必须赋值**。\r\n3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）\r\n\r\n## 接口的实现\r\n\r\n### 基本的实现\r\n\r\n类与接口的关系为实现关系，即**类实现接口**，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 **`implements` 关键字**。\r\n\r\n```java\r\npublic class 实现类名称 implements 接口名称 {\r\n    // 重写接口中的抽象方法【必须】\r\n    // 重写接口中的默认方法【可选】\r\n}\r\n```\r\n\r\n接口的使用步骤：\r\n\r\n1. 接口不能直接使用，需要有一个 `实现类` 来 `实现` 该接口；\r\n2. 接口的实现类必须重写（实现）接口中所有的抽象方法；\r\n3. 创建实现类的对象，进行使用。\r\n\r\n注意事项：\r\n\r\n- 如果实现类并没有重写接口中所有的抽象方法，那么这个类就必须是**抽象类**。\r\n- 接口是**没有静态代码块和构造方法**的。\r\n\r\n### 接口的多实现\r\n\r\n在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的**多实现**。\r\n\r\n实现格式：\r\n\r\n```java\r\npublic class 类名 [extends 父类名] implements 接口名1, 接口名2, ... {\r\n    // 重写接口中的抽象方法【必须】\r\n    // 重写接口中的默认方法【不重名时可选】\r\n}\r\n```\r\n\r\n注意事项：\r\n\r\n- 一个类能**继承一个直接父类，同时实现多个接口。** \r\n- 如果实现类所实现的多个接口中存在重复的抽象方法，那么实现类**只需要重写一次重复的抽象方法。** \r\n- 如果实现类没有重写多有接口中的所有抽象方法，那么实现类必须是一个抽象类。\r\n- 如果实现类所实现的多个接口中存在重复的默认方法，那么实现类**必须对重复的默认方法进行重写。** \r\n- 如果**直接父类中的方法和接口中的默认方法发生冲突，优先使用父类中的方法。** \r\n\r\n## 接口的多继承\r\n\r\n一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。\r\n\r\n接口的继承使用 `extends` 关键字，子接口继承父接口的方法。 \r\n\r\n```java\r\n// 定义父接口A\r\ninterface A {\r\n    public default void method() {\r\n        System.out.println(\"父接口A\");\r\n    }\r\n}\r\n\r\n// 定义父接口A\r\ninterface B {\r\n    public default void method() {\r\n        System.out.println(\"父接口B\");\r\n    }\r\n}\r\n\r\n// 定义子接口C\r\ninterface C extends A, B {\r\n    @Override\r\n    public default void method() {\r\n        System.out.println(\"子接口C\");\r\n    }\r\n}\r\n```\r\n\r\n注意事项：\r\n\r\n1. 多个父接口中的抽象方法重复，没有影响；\r\n2. 多个父接口中的默认方法重复，那么子接口必须进行默认方法的重写，而且不能省略 `default` 关键字。（注意：实现类重写多个接口的重复默认方法时必须去掉 `default` 关键字！）\r\n\r\n## 类和接口相关的几种关系\r\n\r\n1. 类与类之间是单继承的。\r\n2. 类与接口之间是多实现的。\r\n3. 接口与接口之间是多继承的。\r\n\r\n# 多态\r\n\r\n## 多态概述\r\n\r\n`多态` 是继封装、继承之后，面向对象的第三大特性，是指同一行为具有多种不同的表现形式。\r\n\r\n**继承（extends）或实现（implements）是多态性的前提。**一个对象拥有多种形态，这就是对象的多态性。\r\n\r\n## 多态的体现\r\n\r\n多态性的格式体现就是**父类引用指向子类对象**。\r\n\r\n```java\r\n父类类型 对象名 = new 子类类型();\r\n```\r\n\r\n- 父类类型，指子类对象继承的父类类型，或者实现的父接口类型。\r\n- 当使用多态方式调用方法时，首先检查父类中是否具有该方法，如果没有，则编译报错；如果有，则**执行子类重写后的方法**。\r\n\r\n## 多态中的成员变量与成员方法\r\n\r\n访问成员变量的两种方式：\r\n\r\n1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。\r\n2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。\r\n\r\n```java\r\npublic class Fu {\r\n    int num = 10;\r\n\r\n    public void showNum() {\r\n        System.out.println(num);\r\n    }\r\n}\r\n\r\npublic class Zi extends Fu {\r\n    int num = 20;\r\n    int age = 16;\r\n\r\n    @Override\r\n    public void showNum() {\r\n        System.out.println(num);\r\n    }\r\n}\r\n\r\npublic class MultiField {\r\n    public static void main(String[] args) {\r\n        // 使用多态的写法，父类引用指向子类对象\r\n        Fu obj = new Zi();\r\n        \r\n        System.out.println(obj.num); // 父：10\r\n        // System.out.println(obj.age); // 错误写法！\r\n\r\n        // 子类没有重写，就是父：10\r\n        // 子类如果重写，就是子：20\r\n        obj.showNum();\r\n    }\r\n}\r\n```\r\n\r\n调用成员方法的规则是：看 new 的是谁，就优先用谁，没有则向上找。\r\n\r\n```java\r\npublic class Fu {\r\n    public void method() {\r\n        System.out.println(\"父类方法\");\r\n    }\r\n\r\n    public void methodFu() {\r\n        System.out.println(\"父类特有方法\");\r\n    }\r\n}\r\n\r\npublic class Zi extends Fu {\r\n    @Override\r\n    public void method() {\r\n        System.out.println(\"子类方法\");\r\n    }\r\n\r\n    public void methodZi() {\r\n        System.out.println(\"子类特有方法\");\r\n    }\r\n}\r\n\r\npublic class MultiMethod {\r\n    public static void main(String[] args) {\r\n        Fu obj = new Zi(); // 多态\r\n\r\n        obj.method(); // 父子都有，优先用子\r\n        obj.methodFu(); // 子类没有，父类有，向上找到父类\r\n\r\n        // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。\r\n        // obj.methodZi(); // 错误写法！\r\n    }\r\n}\r\n```\r\n\r\n访问成员变量与调用成员方法的对比：\r\n\r\n- 成员变量：编译看左边，运行还看左边。\r\n- 成员方法：编译看左边，运行看右边。\r\n\r\n## 引用类型转换\r\n\r\n### 对象的向上转型\r\n\r\n**向上转型**：多态本身就是子类类型向父类类型转换的过程，这个过程是默认的。 \r\n\r\n- 格式： `父类名称 对象名 = new 子类名称();` \r\n- 含义：创建一个子类对象，把它当做父类来看待使用。\r\n- 注意：向上转型一定是安全的，类似于基本数据类型中的自动类型转换。\r\n\r\n### 对象的向下转型\r\n\r\n对象一旦向上转型为父类类型，就无法调用子类原本特有的内容，所以需要将对象还原为子类类型。\r\n\r\n**向下转型**：父类类型向子类类型转换的过程，这个过程是强制的。 \r\n\r\n- 格式： `子类名称 对象名 = (子类名称)父类对象` \r\n- 含义：将父类对象**还原**为本来的子类对象。\r\n- 注意：如果对象不属于要还原的类型，运行时就会抛出 `ClassCastException` 异常。类似于基本数据类型中的强制类型转换。\r\n\r\n##  `instanceof` 关键字\r\n\r\n为了避免 `ClassCastException` 的发生，Java 提供了 `instanceof` 关键字，给引用变量做类型校验，用来判断父类对象是否是某个引用类型的实例。\r\n\r\n```java\r\n对象名 instanceof 引用数据类型\r\n```\r\n\r\n这将得到一个 boolean 值结果。\r\n\r\n#  `final` 关键字\r\n\r\n##  `final` 概述\r\n\r\n子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承 API 中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写继承的 API 中提供的类的内容的情况，Java 提供了 **`final` 关键字**，用于修饰**不可改变**内容。 \r\n\r\n- `final` ：代表最终，不可改变，可用于修饰 `类` 、`方法` 和 `变量`。\r\n    - 类：被修饰的类，不能被继承。\r\n    - 方法：被修饰的方法，不能被重写。\r\n    - 变量：被修饰的变量，不能被重新赋值。\r\n\r\n##  `final` 的使用方式\r\n\r\n### 修饰类\r\n\r\n```java\r\npublic final class 类名 {\r\n    ...\r\n}\r\n```\r\n\r\n- 含义：当前这个类不能有任何的子类。\r\n- 注意：一个类如果是 final 的，那么其中所有的成员方法都无法进行重写（因为没有子类）。\r\n\r\n### 修饰方法\r\n\r\n```java\r\n修饰符 final 返回值类型 方法名(参数列表) {\r\n    // 方法体\r\n}\r\n```\r\n\r\n- 含义：当前这个方法是最终方法，不能被重写。\r\n- 注意：对类、方法来说，`abstract` 关键字和 `final` 关键字不能同时使用，因为二者的含义矛盾。\r\n\r\n### 修饰变量\r\n\r\n#### 修饰局部变量\r\n\r\n基本类型的局部变量，被 final 修饰后，**只能赋值一次**，不能再更改。\r\n\r\n```java\r\npublic class FinalFieldDemo1 {\r\n    public static void main(String[] args) {\r\n        // 声明变量，使用final修饰\r\n        final int a;\r\n        // 第一次赋值\r\n        a = 10;\r\n        // 第二次赋值\r\n        // a = 20; // 报错,不可重新赋值\r\n        \r\n        // 声明变量，直接赋值，使用final修饰\r\n        final int b = 10;\r\n        // 第二次赋值\r\n        // b = 20; // 报错,不可重新赋值\r\n    }\r\n}\r\n```\r\n\r\n引用类型的局部变量，被 final 修饰后，只能指向一个对象，**地址不能再更改，但是不影响对象内部的成员变量值的修改**。\r\n\r\n```java\r\npublic class FinalFieldDemo2 {\r\n    public static void main(String[] args) {\r\n        // 创建 User 对象\r\n        final User u = new User();\r\n        \r\n        // 创建 另一个 User对象\r\n        // u = new User(); // 报错，指向了新的对象，地址值改变。\r\n        \r\n        // 调用setName方法\r\n        u.setName(\"张三\"); // 可以修改\r\n    }\r\n}\r\n```\r\n\r\n#### 修饰成员变量\r\n\r\n对于成员变量来说，如果使用 final 关键字修饰，那么这个变量也照样是不可变。\r\n\r\n1. 由于成员变量具有默认值，所以用了 final 之后必须手动赋值，不会再给默认值了。\r\n2. 对于 final 的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一。\r\n3. 必须保证类当中所有重载的构造方法，都最终会对 final 的成员变量进行赋值。\r\n\r\n```java\r\npublic class Person {\r\n    private final String name/* = \"鹿晗\"*/;\r\n\r\n    public Person() {\r\n        name = \"关晓彤\";\r\n    }\r\n\r\n    public Person(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /*\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    */\r\n}\r\n```\r\n\r\n# 访问权限修饰符\r\n\r\n## 访问修饰符概述\r\n\r\n在 Java 中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限。 \r\n\r\n- `public`：公有的\r\n- `protected`：受保护的\r\n- `(default)`：默认的\r\n- `private`：私有的\r\n\r\n## 不同权限的访问能力\r\n\r\n|              | `public` | `protected` | `(default)` | `private` |\r\n| :----------- | :------: | :---------: | :---------: | :-------: |\r\n| 同一类       |    √     |      √      |      √      |     √     |\r\n| 同一包       |    √     |      √      |      √      |           |\r\n| 不同包子类   |    √     |      √      |             |           |\r\n| 不同包无关类 |    √     |             |             |           |\r\n\r\n编写代码时，如果没有特殊的考虑，建议这样使用权限： \r\n\r\n- 成员变量使用 `private`，隐藏细节。 \r\n- 构造方法使用 `public`，方便创建对象。 \r\n- 成员方法使用 `public`，方便调用方法。 \r\n\r\n# 内部类\r\n\r\n## 内部类概述\r\n\r\n如果一个事物包含另一个事物，就对应着一个类包含另一个类。例如：身体和心脏的关系，汽车和发动机的关系。\r\n\r\n将一个类 A 定义在另一个类 B 里面，类 A 就称为 **`内部类`**，B 则称为 **`外部类`**。 \r\n\r\n内部类的分类：\r\n\r\n- 成员内部类\r\n- 局部内部类（包含匿名内部类）\r\n\r\n## 成员内部类\r\n\r\n`成员内部类` ：定义在**类中方法外**的类。\r\n\r\n```java\r\n修饰符 class 外部类名称 {\r\n    修饰符 class 内部类名称 {\r\n        // ...\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n### 访问特点\r\n\r\n- 内部类可以**直接访问外部类的成员**，包括私有成员。\r\n- 外部类要访问内部类的成员，必须要**创建内部类对象**。\r\n\r\n### 使用方式\r\n\r\n1. 间接方式：在外部类方法中创建内部类对象，在 main 方法中调用外部类方法。\r\n2. 直接方式：在 main 方法中直接创建内部类对象。\r\n\r\n创建内部类对象的格式：\r\n\r\n```java\r\n外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();\r\n```\r\n\r\n```java\r\npublic class Body { // 外部类\r\n    public class Heart { // 成员内部类\r\n        // 内部类的方法\r\n        public void beat() {\r\n            System.out.println(\"心脏跳动：蹦蹦蹦！\");\r\n            System.out.println(\"我叫：\" + name); // 正确写法！\r\n        }\r\n    }\r\n    \r\n    // 外部类的成员变量\r\n    private String name;\r\n    \r\n    // 外部类的方法\r\n    public void methodBody() {\r\n        System.out.println(\"外部类的方法\");\r\n        new Heart().beat();\r\n    }\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\npublic class Demo01InnerClass {\r\n    public static void main(String[] args) {\r\n        Body body = new Body(); // 外部类的对象\r\n        // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart\r\n        body.methodBody();\r\n        \r\n        // 直接按照格式创建内部类对象\r\n        Body.Heart heart = new Body().new Heart();\r\n        heart.beat();\r\n    }\r\n}\r\n```\r\n\r\n### 同名变量访问\r\n\r\n如果外部类成员变量、内部类成员变量和局部变量同名：\r\n\r\n- 通过 `变量名` 访问局部变量\r\n- 通过 `this.变量名` 访问内部类成员变量\r\n- 通过 `外部类名称.this.变量名` 访问外部类成员变量（注意：没有继承关系，不能用 super）\r\n\r\n```java\r\npublic class Outer {\r\n    int num = 10; // 外部类的成员变量\r\n    public class Inner /*extends Object*/ {\r\n        int num = 20; // 内部类的成员变量\r\n        public void methodInner() {\r\n            int num = 30; // 内部类方法的局部变量\r\n            System.out.println(num); // 局部变量，就近原则\r\n            System.out.println(this.num); // 内部类的成员变量\r\n            System.out.println(Outer.this.num); // 外部类的成员变量\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 局部内部类\r\n\r\n`局部内部类` ：定义在方法内部的类。\r\n\r\n“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。\r\n\r\n```java\r\n修饰符 class 外部类名称 {\r\n    修饰符 返回值类型 外部类方法名称(参数列表) {\r\n        class 局部内部类名称 {\r\n            // ...\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 使用方式\r\n\r\n在外部类方法中创建局部内部类对象来使用。\r\n\r\n```java\r\nclass Outer {\r\n    public void methodOuter() {\r\n        class Inner { // 局部内部类\r\n            int num = 10;\r\n            public void methodInner() {\r\n                System.out.println(num); // 10\r\n            }\r\n        }\r\n        // 创建局部内部类对象\r\n        Inner inner = new Inner();\r\n        inner.methodInner();\r\n    }\r\n}\r\n```\r\n\r\n### 访问 `final` 局部变量\r\n\r\n局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是 `有效final` 的。\r\n\r\n- 直接声明为 `final` \r\n- 实际只赋值一次（注意：从 Java 8 开始，只要局部变量事实不变，那么 `final` 关键字可以省略。）\r\n\r\n原因：\r\n\r\n1. new 出来的对象在堆内存当中。\r\n2. 局部变量是跟着方法走的，在栈内存当中。\r\n3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。\r\n4. 但是 new 出来的对象会在堆当中持续存在，直到垃圾回收消失。\r\n\r\n# 类的权限修饰符小结\r\n\r\n定义一个类的时候，权限修饰符规则如下：\r\n\r\n1. 外部类：`public` / `(default)` \r\n2. 成员内部类：`public` / `protected` / `(default)` / `private` \r\n3. 局部内部类：什么权限修饰符都不能写（注意：不是 default）\r\n\r\n# 匿名的使用\r\n\r\n## 匿名内部类\r\n\r\n如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用 `匿名内部类`。\r\n\r\n**匿名内部类** ：是内部类的简化写法。它的本质是一个 `带具体实现的` `父类或者父接口的` `匿名的` **子类对象**。 \r\n\r\n匿名内部类的定义格式：\r\n\r\n```java\r\n接口名称 对象名 = new 接口名称() {\r\n    // 覆盖重写所有抽象方法\r\n};\r\n\r\n抽象类名称 对象名 = new 抽象类名称() {\r\n    // 覆盖重写所有抽象方法\r\n};\r\n```\r\n\r\n对格式 `new 父类名称() {...}` 进行解析：\r\n\r\n- `new` 代表创建对象的动作\r\n- `父类名称` 就是匿名内部类需要实现的父类类型\r\n- `{...}` 才是匿名内部类的内容\r\n\r\n## 匿名对象\r\n\r\n创建对象的标准格式：`类名称 对象名 = new 类名称();` \r\n\r\n匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。\r\n\r\n```java\r\nnew 类名();\r\n```\r\n\r\n使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。\r\n\r\n使用场景：\r\n\r\n1. 创建匿名对象直接调用方法，没有变量名。\r\n2. 匿名对象可以作为方法的参数和返回值。\r\n\r\n## 注意事项\r\n\r\n1. 匿名内部类，在**创建对象**的时候，只能使用唯一一次。\r\n    如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。\r\n2. 匿名对象，在**调用方法**的时候，只能调用唯一一次。\r\n    如果希望同一个对象，调用多次方法，那么必须给对象起个名字。\r\n3. 匿名内部类是**省略了实现类/子类名称**，但是匿名对象是**省略了对象名称**。\r\n    强调：匿名内部类和匿名对象不是一回事！！！\r\n\r\n# 引用类型用法总结\r\n\r\n基本类型可以作为成员变量、方法的参数以及方法的返回值，引用类型也可以。\r\n\r\n`String` 类型本身就是引用类型，因为它的使用方式类似常量，所以往往忽略了它是引用类型的存在。\r\n\r\n## class 作为成员变量\r\n\r\n类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。 \r\n\r\n```java\r\npublic class Weapon {\r\n    private String code; // 武器的代号\r\n\r\n    public Weapon() {\r\n    }\r\n\r\n    public Weapon(String code) {\r\n        this.code = code;\r\n    }\r\n\r\n    public String getCode() {\r\n        return code;\r\n    }\r\n\r\n    public void setCode(String code) {\r\n        this.code = code;\r\n    }\r\n}\r\n\r\npublic class Hero {\r\n    private String name; // 英雄的名字\r\n    private int age; // 英雄的年龄\r\n    private Weapon weapon; // 英雄的武器\r\n\r\n    public Hero() {\r\n    }\r\n\r\n    public Hero(String name, int age, Weapon weapon) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.weapon = weapon;\r\n    }\r\n\r\n    public void attack() {\r\n        System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" \r\n                           + weapon.getCode() + \"攻击敌方。\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Weapon getWeapon() {\r\n        return weapon;\r\n    }\r\n\r\n    public void setWeapon(Weapon weapon) {\r\n        this.weapon = weapon;\r\n    }\r\n}\r\n\r\npublic class DemoMain {\r\n    public static void main(String[] args) {\r\n        // 创建一个英雄角色\r\n        Hero hero = new Hero();\r\n        // 为英雄起一个名字，并且设置年龄\r\n        hero.setName(\"盖伦\");\r\n        hero.setAge(20);\r\n\r\n        // 创建一个武器对象\r\n        Weapon weapon = new Weapon(\"AK-47\");\r\n        // 为英雄配备武器\r\n        hero.setWeapon(weapon);\r\n\r\n        // 年龄为20的盖伦用AK-47攻击敌方。\r\n        hero.attack();\r\n    }\r\n}\r\n```\r\n\r\n## interface 作为成员变量\r\n\r\n接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。 \r\n\r\n```java\r\npublic interface Skill {\r\n    void use(); // 释放技能的抽象方法\r\n}\r\n\r\npublic class Hero {\r\n    private String name; // 英雄的名称\r\n    private Skill skill; // 英雄的技能\r\n\r\n    public Hero() {\r\n    }\r\n\r\n    public Hero(String name, Skill skill) {\r\n        this.name = name;\r\n        this.skill = skill;\r\n    }\r\n\r\n    public void attack() {\r\n        System.out.println(\"我叫\" + name + \"，开始释放技能：\");\r\n        skill.use(); // 调用接口中的抽象方法\r\n        System.out.println(\"释放技能完成。\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Skill getSkill() {\r\n        return skill;\r\n    }\r\n\r\n    public void setSkill(Skill skill) {\r\n        this.skill = skill;\r\n    }\r\n}\r\n\r\npublic class DemoGame {\r\n    public static void main(String[] args) {\r\n        Hero hero = new Hero();\r\n        hero.setName(\"艾希\"); // 设置英雄的名称\r\n\r\n        // 设置英雄技能\r\n        // 同时使用匿名内部类和匿名对象\r\n        hero.setSkill(new Skill() {\r\n            @Override\r\n            public void use() {\r\n                System.out.println(\"Biu~Pia~Biu~Pia~\");\r\n            }\r\n        });\r\n        \r\n        /*\r\n        我叫艾希，开始释放技能：\r\n        Biu~Pia~Biu~Pia~\r\n        释放技能完成。\r\n        */\r\n        hero.attack();\r\n    }\r\n}\r\n```\r\n\r\n## interface 作为方法参数和返回值类型\r\n\r\n- 接口作为参数时，传递它的子类对象。\r\n- 接口作为返回值类型时，返回它的子类对象。\r\n\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/*\r\njava.util.List正是ArrayList所实现的接口。\r\n */\r\npublic class DemoInterface {\r\n    public static void main(String[] args) {\r\n        // 左边是接口名称，右边是实现类名称，这就是多态写法\r\n        List<String> list = new ArrayList<>();\r\n\r\n        List<String> result = addNames(list);\r\n        for (int i = 0; i < result.size(); i++) {\r\n            System.out.println(result.get(i));\r\n        }\r\n    }\r\n\r\n    public static List<String> addNames(List<String> list) {\r\n        list.add(\"迪丽热巴\");\r\n        list.add(\"古力娜扎\");\r\n        list.add(\"玛尔扎哈\");\r\n        list.add(\"沙扬娜拉\");\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n# Lambda 表达式\r\n\r\n## 函数式编程思想\r\n\r\n在数学中，**函数**就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法，**强调做什么，而不是以什么形式做**。\r\n\r\n- 面向对象的思想：做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情。\r\n- 函数式编程思想：只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。\r\n\r\n## 冗余的传统代码\r\n\r\n给定一个计算器 `Calculator` 接口，内含抽象方法 `calc` 可以将两个 `int` 数字相加得到和值。在测试类中定义一个 `invokeCalc` 方法，完成加法计算。\r\n\r\n```java\r\npublic interface Calculator {\r\n    public abstract int calc(int a, int b);\r\n}\r\n\r\npublic class DemoCalculator {\r\n    public static void main(String[] args) {\r\n        // 调用invokeCalc方法,方法的参数是一个接口,可以使用匿名内部类\r\n        invokeCalc(10, 20, new Calculator() {\r\n            @Override\r\n            public int calc(int a, int b) {\r\n                return a + b;\r\n            }\r\n        });\r\n    }\r\n    \r\n    public static void invokeCalc(int a, int b, Calculator c) {\r\n        int sum = c.calc(a, b);\r\n        System.out.println(sum);\r\n    }\r\n}\r\n```\r\n\r\n本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个 `Calculator` 接口的匿名内部类对象来明确加法计算内容，再将其传递给 `invokeCalc` 方法使用。\r\n\r\n对于 `Calculator` 的匿名内部类用法，可以分析出几点内容：\r\n\r\n- `invokeCalc` 方法需要 `Calculator` 接口作为参数，其中的抽象 `calc` 方法明确了两个数的运算方式；\r\n- 为了指定 `calc` 的方法体，**不得不**需要 `Calculator` 接口的实现类；\r\n- 为了省去定义一个 `PlusCalculator` 实现类的麻烦，**不得不**使用匿名内部类；\r\n- 必须覆盖重写抽象 `calc` 方法，所以方法名称、方法参数、方法返回值**不得不**再写一遍，且不能写错；\r\n- 而实际上，**似乎只有方法体才是关键所在**。\r\n\r\n## 体验 Lambda 的更优写法\r\n\r\n2014 年 3 月 Oracle 所发布的 Java 8（JDK 1.8）中，加入了 **Lambda 表达式**的重量级新特性，为我们打开了新世界的大门。\r\n\r\n借助 Java 8 的全新语法，上述 `Calculator` 接口的匿名内部类写法可以通过更简单的 Lambda 表达式达到等效：\r\n\r\n```java\r\npublic class DemoCalculator {\r\n    public static void main(String[] args) {\r\n        // 使用Lambda表达式简化匿名内部类的书写\r\n        invokeCalc(120, 130, (int a,int b) -> {return a + b;});\r\n    }\r\n}\r\n```\r\n\r\n## Lambda 标准格式\r\n\r\nLambda 省去面向对象的条条框框，格式由 **3 个部分**组成：\r\n\r\n- 一些参数\r\n- 一个箭头\r\n- 一段代码\r\n\r\n```java\r\n(参数列表) -> { 重写方法的代码 }\r\n```\r\n\r\n格式说明：\r\n\r\n- `()` ：与接口中抽象方法的参数列表一致，没有参数则留空；有参数就写出参数，多个参数使用逗号分隔。\r\n- `->` ：是新引入的语法格式，代表指向动作，是传递的意思，把参数传递给方法体 `{}`。\r\n- `{}`：重写接口的抽象方法的方法体。\r\n\r\n## Lambda 省略格式\r\n\r\n### 可推导即可省略\r\n\r\nLambda 强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用 Lambda 的省略写法：\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    invokeCalc(120, 130, (a, b) -> a + b);\r\n}\r\n```\r\n\r\n### 省略规则\r\n\r\n在 Lambda 标准格式的基础上，使用省略写法的规则为：\r\n\r\n1. 小括号内参数的类型可以省略；\r\n2. 如果小括号内**有且仅有一个参数**，则小括号可以省略；\r\n3. 如果大括号内**有且仅有一个语句**，则无论是否有返回值，都可以省略大括号、`return` 关键字及语句分号。\r\n    注意：要省略 `{}`，`return`，`;` 必须一起省略。\r\n\r\n## Lambda 的使用前提\r\n\r\nLambda 的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：\r\n\r\n1. 使用 Lambda 必须具有接口，且要求**接口中有且仅有一个抽象方法**。\r\n    - 无论是 JDK 内置的 `Runnable`、`Comparator` 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用 Lambda。\r\n2. 使用 Lambda 必须具有**上下文推断**。\r\n    - 也就是方法的参数或局部变量类型必须为 Lambda 对应的接口类型，才能使用 Lambda 作为该接口的实例。\r\n\r\n备注：有且仅有一个抽象方法的接口，称为“**函数式接口**”。', 'https://images.pexels.com/photos/956981/milky-way-starry-sky-night-sky-star-956981.jpeg', '原创', 0, 1, 1, 1, 1, 1, '2020-07-23 05:04:36', '2020-07-23 05:04:36', 'Java 语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。');

-- ----------------------------
-- Table structure for blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `blog_tag`;
CREATE TABLE `blog_tag`  (
  `blog_tag_id` int NOT NULL AUTO_INCREMENT,
  `blog_id` int NULL DEFAULT NULL,
  `tag_id` int NULL DEFAULT NULL,
  PRIMARY KEY (`blog_tag_id`) USING BTREE,
  INDEX `FK_Reference_4`(`blog_id`) USING BTREE,
  INDEX `FK_Reference_5`(`tag_id`) USING BTREE,
  CONSTRAINT `FK_Reference_4` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`blog_id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK_Reference_5` FOREIGN KEY (`tag_id`) REFERENCES `tag` (`tag_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_tag
-- ----------------------------
INSERT INTO `blog_tag` VALUES (4, 2, 2);
INSERT INTO `blog_tag` VALUES (5, 2, 5);
INSERT INTO `blog_tag` VALUES (6, 1, 1);
INSERT INTO `blog_tag` VALUES (7, 1, 5);
INSERT INTO `blog_tag` VALUES (8, 3, 6);
INSERT INTO `blog_tag` VALUES (9, 4, 7);
INSERT INTO `blog_tag` VALUES (10, 5, 7);

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comment_id` int NOT NULL AUTO_INCREMENT,
  `blog_id` int NULL DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `parent_comment_id` int NULL DEFAULT NULL,
  PRIMARY KEY (`comment_id`) USING BTREE,
  INDEX `FK_Reference_3`(`blog_id`) USING BTREE,
  CONSTRAINT `FK_Reference_3` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`blog_id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, 2, 'Flexia', 'flexia@gmail.com', '测试', '/images/avatar.jpg', '2020-07-22 09:30:00', -1);
INSERT INTO `comment` VALUES (2, 2, 'Hustffx', 'hustffx@hust.edu.cn', '回复测试', '/images/avatar.jpg', '2020-07-22 09:31:33', 1);
INSERT INTO `comment` VALUES (3, 2, '小方方', 'smallfun@qq.com', '写的真好！！彩虹屁！！', '/images/avatar.jpg', '2020-07-22 09:32:27', -1);
INSERT INTO `comment` VALUES (4, 2, '小方方', 'smallfun@qq.com', '再回复', '/images/avatar.jpg', '2020-07-22 10:30:25', 2);
INSERT INTO `comment` VALUES (5, 2, 'Flexia', 'flexia@gmail.com', '好累啊', '/images/avatar.jpg', '2020-07-22 10:53:35', 4);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `tag_id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'SpringBoot');
INSERT INTO `tag` VALUES (2, 'Spring');
INSERT INTO `tag` VALUES (3, 'SpringMVC');
INSERT INTO `tag` VALUES (4, 'MyBatis');
INSERT INTO `tag` VALUES (5, '学习笔记');
INSERT INTO `tag` VALUES (6, '数据库');
INSERT INTO `tag` VALUES (7, 'JavaSE');

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type`  (
  `type_id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`type_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES (1, 'SpringBoot');
INSERT INTO `type` VALUES (2, 'Spring');
INSERT INTO `type` VALUES (3, 'SpringMVC');
INSERT INTO `type` VALUES (4, 'MyBatis');
INSERT INTO `type` VALUES (5, '数据库');
INSERT INTO `type` VALUES (6, 'JavaSE');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `user_id` int NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` int NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, '小方方', 'hustffx', 'e10adc3949ba59abbe56e057f20f883e', 'fangfengxin98@163.com', 'https://picsum.photos/id/883/200/200', NULL, NULL, NULL);

SET FOREIGN_KEY_CHECKS = 1;